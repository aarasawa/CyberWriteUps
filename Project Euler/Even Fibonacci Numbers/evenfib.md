# Even Fibonacci Numbers

### Problem
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:  1,2,3,5,8,13,21,34,55,89
By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

### Approach
The first thing that comes to mind when thinking of fibonacci is recursion. 

### Fibonacci
Fibonacci numbers are a series of numbers where each subsequent number is the sum of the last two numbers in the series. If that was confusing, we can explain a bit more. Typically in Fibonacci sequences, there are starting numbers provided as a base for the sequence. For the case of this problem, the starting numbers, a0 and a1, are 1 and 2, respectively. The **next number** in the sequence is the sum of these starting numbers, a0 and a1. It is like this for every subsequent number in the series. 

``` python
  a0 = 1
  a1 = 2
  a2 = a0 + a1 = 1 + 2 = 3
  a2 = 3
```

### What is Recursion?
Recursion in programming, is the principle of calling a function inside of itself. This fits with the concept of generatng a Fibonacci sequence because it mimics the behavior of how new numbers are found. Programmatically, this would look like:

``` python
  fib(num):
    return fib(num-1) + fib(num-2)
```

### Efficiency
In terms of computing resource, recursion has a lot of overhead. Each time the function is called, there is overhead incurred from parameter passing, stack frame allocation, etc. For this specific situation, a lot of resources are wasted in recalculating numbers that have already been found. The simplest way to mitigate this problem is to add a dictionary for quick lookup times. So we can add a conditional to look up if numbers have already been calculated and use them if they are and to add new numbers to the dictionary when they are calcuated. Because we know that previous numbers have already been calculated, then we can assume they are in the dictionary. 

Alternatively you can manually increase the recursion depth and wait for the program to finish. 

``` python
  fib(number):
    ...

    if number in dictionary:
      return dictionary[number]
    
    new_number = fib(n-1) - fib(n-2)
    if new_number not in dictionary:
      dictionary[number] = new_number
    
    ...
```