# Format String Bug

#### Intro
Format strings are control strings passed to printf() functions in C e.g. printf, sprintf, fprintf. The vulnerability emerges from unvalidated input into these functions by a user. Worse case, memory reads and writes can be performed. 

#### Format String Bugs
In C, <b>variadic function</b> are declared with the list of arguments ending in '...'. The first part of the function is the only part that is validated. On 64-but systems, the first 6 arguments are passed in registers and additional arguments are pushed onto the stack. 

In the second line, each '%' character is interpreted as a format specifier. If there are no corresponding arguments in the function, <code>printf</code> will read the registers or memory locations of arguments.

``` C
 int printf(const char *fmt, ...);
 printf(buf);

 //correct way to print a string
 puts(buf);
 printf("%s", buf);
```

#### Exploiting Format String Bugs
<code>printf()</code> can also write to memory. An instruction pointer sees character as an instruction to print the character. For printf(), the machine interprets each character as an "operation" so the instruction pointer moves past the character in the string and the output counter is incremented by one. 

``` C
1 a <---- instruction ptr
2 b
3 c
4 d
```

#### Stack Reads
On 32-bit systems, a series of '%x' specifiers in printf() causes it to print successive lines from the stack. On 64-bit systems, the first 5 '%lx' will print contents from <b>rsi, rdx, rcx, r8, r9</b> registers, additional '%lx' will start printing successive stack lines. 

32-bit systems using <b>%x</b>: can read canary
64-bit systems using <b>%lx</b>: read canary, using '%x' will only read 4 bytes

The difficulty lies in the fact that argument pointers only moves forward by 1 froma format specifier. 

#### Random Access to Arguments
Format string can access its arguments in random order using %n$ to the select the <i>nth</i> argument. For example, if we know the canary is <i>n</i> stack-lines below ptr to format string then a format specifier like 
%n$$x prints the canary on 32-bit systems and %(n + 5)$lx does the same for 64-bit systems.

``` C
  printf("%4$d %1$d %3$d %2$d\n", 10, 20, 30, 40);
```

This was possible on older versions of glibc. Standards now are random access and sequential argument access. Once argument numbers have been collected, there can be no gaps left.  If no-gaps is enforced, random access arguments cannot be used to on the buffer. 

#### Arbitrary Memory Reads
Ultimate power comes from the ability to overwrite memory words with arbitrary values. 

First difficulty: Using <code>%n</code> and using the address from the format string to control the output counter. 
> Controlling output counter can be done with instructions like <code>%mc</code> to increment the output counter by exactly m. An instruction like %ms will always output <i>at least m</i> bytes, whereas %.ms outputs <i>at most m</i> bytes. For exactly m bytes, use <code>%m.ms</code>.

Second difficulty: Write a very large value (like address of function)
> Using <code>%hn</code> truncates the counter to a short (2 bytes). Even <code>%hhn</code> truncates to a char. Using %hhn 4 times on consecutive address, you can write any 32-bit value one byte at a time, incrementing output counter by a max of 255 bytes. 

``` C
 //To write 0x44552233 and LSB of output counter starts at 32
 %36c%hhn%17c%hhn%205c%hhn%17c%hhn
```
1st instruction sets the counter to 32 + 36 = 68 = hex(44).  
2nd instruction writes to memory.  
3rd instruction sets counter to 68 + 17 = 85 = hex(55).  
4th instruction writse the new counter to memory.  
5th instruction sets counter to 205 + 85 = 290 = hex(122).  
6th instruction writes its LSB hex(22) to memory.  
7th instruction sets counter to 290 + 17 = 307 = hex(133).  
8th instruction writes final hex(33).  

We still need to provide arguments for the %hhn instructions. Because the argument ptr is moving sequentially, we need to provide dummary args to each %mc. 

``` C
  AAAA\x04\x03\x02\x01BBBB\x05\x03\x02\x01 //AAAA is the dummy arg
  CCCC\x06\x03\x02\x01DDDD\x07\x03\x02\x01 //CCCC is the dummy arg
```
Suppose <i>o</i> is zero, the format string is stack line aligned, 32-bit system, and we want to write <code>0x44552233</code> to memory address <code>0x01020304</code>. A format string such as the one above would be crafted. The dummy args in the example serve to re-align next arg to the stack line. Other args are the addresses of all bytes of the target memory location starting from the LSB.